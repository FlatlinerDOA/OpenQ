//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args){
  this.auth_request = null
if( args != null ){  if (null != args.auth_request)
  this.auth_request = args.auth_request
}}
Cassandra_login_args.prototype = {}
Cassandra_login_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest()
        this.auth_request.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_args')
  if (null != this.auth_request) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1)
    this.auth_request.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_login_result = function(args){
  this.authnx = null
  this.authzx = null
if( args != null ){  if (null != args.authnx)
  this.authnx = args.authnx
  if (null != args.authzx)
  this.authzx = args.authzx
}}
Cassandra_login_result.prototype = {}
Cassandra_login_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException()
        this.authnx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException()
        this.authzx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_result')
  if (null != this.authnx) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1)
    this.authnx.write(output)
    output.writeFieldEnd()
  }
  if (null != this.authzx) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2)
    this.authzx.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_set_keyspace_args.prototype = {}
Cassandra_set_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_result = function(args){
  this.ire = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_set_keyspace_result.prototype = {}
Cassandra_set_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_args = function(args){
  this.key = null
  this.column_path = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_args.prototype = {}
Cassandra_get_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_result = function(args){
  this.success = null
  this.ire = null
  this.nfe = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_result.prototype = {}
Cassandra_get_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_slice_args.prototype = {}
Cassandra_get_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_slice_result.prototype = {}
Cassandra_get_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size67 = 0
          var rtmp3
          this.success = []
          var _etype70 = 0
          rtmp3 = input.readListBegin()
          _etype70 = rtmp3.etype
          _size67 = rtmp3.size
          for (var _i71 = 0; _i71 < _size67; ++_i71)
          {
            var elem72 = null
            elem72 = new ttypes.ColumnOrSuperColumn()
            elem72.read(input)
            this.success.push(elem72)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter73 in this.success)
        {
          if (this.success.hasOwnProperty(iter73))
          {
            iter73=this.success[iter73]
            iter73.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_count_args.prototype = {}
Cassandra_get_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_count_result.prototype = {}
Cassandra_get_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0)
    output.writeI32(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_slice_args.prototype = {}
Cassandra_multiget_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size74 = 0
          var rtmp3
          this.keys = []
          var _etype77 = 0
          rtmp3 = input.readListBegin()
          _etype77 = rtmp3.etype
          _size74 = rtmp3.size
          for (var _i78 = 0; _i78 < _size74; ++_i78)
          {
            var elem79 = null
            elem79 = input.readString()
            this.keys.push(elem79)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter80 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter80))
          {
            iter80=this.keys[iter80]
            output.writeString(iter80)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_slice_result.prototype = {}
Cassandra_multiget_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size81 = 0
          var rtmp3
          this.success = {}
          var _ktype82 = 0
          var _vtype83 = 0
          rtmp3 = input.readMapBegin()
          _ktype82= rtmp3.ktype
          _vtype83= rtmp3.vtype
          _size81= rtmp3.size
          for (var _i85 = 0; _i85 < _size81; ++_i85)
          {
            key86 = null
            val87 = null
            key86 = input.readString()
            {
              var _size88 = 0
              var rtmp3
              val87 = []
              var _etype91 = 0
              rtmp3 = input.readListBegin()
              _etype91 = rtmp3.etype
              _size88 = rtmp3.size
              for (var _i92 = 0; _i92 < _size88; ++_i92)
              {
                var elem93 = null
                elem93 = new ttypes.ColumnOrSuperColumn()
                elem93.read(input)
                val87.push(elem93)
              }
              input.readListEnd()
            }
            this.success[key86] = val87
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter94 in this.success)        {
          if (this.success.hasOwnProperty(kiter94))
          {
            var viter95 = this.success[kiter94]
            output.writeString(kiter94)
            {
              output.writeListBegin(Thrift.Type.STRUCT, viter95.length)
              {
                for(var iter96 in viter95)
                {
                  if (viter95.hasOwnProperty(iter96))
                  {
                    iter96=viter95[iter96]
                    iter96.write(output)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_count_args.prototype = {}
Cassandra_multiget_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size97 = 0
          var rtmp3
          this.keys = []
          var _etype100 = 0
          rtmp3 = input.readListBegin()
          _etype100 = rtmp3.etype
          _size97 = rtmp3.size
          for (var _i101 = 0; _i101 < _size97; ++_i101)
          {
            var elem102 = null
            elem102 = input.readString()
            this.keys.push(elem102)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter103 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter103))
          {
            iter103=this.keys[iter103]
            output.writeString(iter103)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_count_result.prototype = {}
Cassandra_multiget_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size104 = 0
          var rtmp3
          this.success = {}
          var _ktype105 = 0
          var _vtype106 = 0
          rtmp3 = input.readMapBegin()
          _ktype105= rtmp3.ktype
          _vtype106= rtmp3.vtype
          _size104= rtmp3.size
          for (var _i108 = 0; _i108 < _size104; ++_i108)
          {
            key109 = null
            val110 = null
            key109 = input.readString()
            val110 = input.readI32()
            this.success[key109] = val110
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success))
      {
        for(var kiter111 in this.success)        {
          if (this.success.hasOwnProperty(kiter111))
          {
            var viter112 = this.success[kiter111]
            output.writeString(kiter111)
            output.writeI32(viter112)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_args = function(args){
  this.column_parent = null
  this.predicate = null
  this.range = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.range)
  this.range = args.range
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_range_slices_args.prototype = {}
Cassandra_get_range_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange()
        this.range.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.range) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3)
    this.range.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_range_slices_result.prototype = {}
Cassandra_get_range_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size113 = 0
          var rtmp3
          this.success = []
          var _etype116 = 0
          rtmp3 = input.readListBegin()
          _etype116 = rtmp3.etype
          _size113 = rtmp3.size
          for (var _i117 = 0; _i117 < _size113; ++_i117)
          {
            var elem118 = null
            elem118 = new ttypes.KeySlice()
            elem118.read(input)
            this.success.push(elem118)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter119 in this.success)
        {
          if (this.success.hasOwnProperty(iter119))
          {
            iter119=this.success[iter119]
            iter119.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_args = function(args){
  this.column_parent = null
  this.index_clause = null
  this.column_predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.index_clause)
  this.index_clause = args.index_clause
  if (null != args.column_predicate)
  this.column_predicate = args.column_predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_indexed_slices_args.prototype = {}
Cassandra_get_indexed_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause()
        this.index_clause.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate()
        this.column_predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.index_clause) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2)
    this.index_clause.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column_predicate) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3)
    this.column_predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_indexed_slices_result.prototype = {}
Cassandra_get_indexed_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size120 = 0
          var rtmp3
          this.success = []
          var _etype123 = 0
          rtmp3 = input.readListBegin()
          _etype123 = rtmp3.etype
          _size120 = rtmp3.size
          for (var _i124 = 0; _i124 < _size120; ++_i124)
          {
            var elem125 = null
            elem125 = new ttypes.KeySlice()
            elem125.read(input)
            this.success.push(elem125)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter126 in this.success)
        {
          if (this.success.hasOwnProperty(iter126))
          {
            iter126=this.success[iter126]
            iter126.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_args = function(args){
  this.key = null
  this.column_parent = null
  this.column = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.column)
  this.column = args.column
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_insert_args.prototype = {}
Cassandra_insert_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_insert_result.prototype = {}
Cassandra_insert_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_args = function(args){
  this.key = null
  this.column_path = null
  this.timestamp = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.timestamp)
  this.timestamp = args.timestamp
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_remove_args.prototype = {}
Cassandra_remove_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_remove_result.prototype = {}
Cassandra_remove_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_args = function(args){
  this.mutation_map = null
  this.consistency_level = 1
if( args != null ){  if (null != args.mutation_map)
  this.mutation_map = args.mutation_map
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_batch_mutate_args.prototype = {}
Cassandra_batch_mutate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.MAP) {
        {
          var _size127 = 0
          var rtmp3
          this.mutation_map = {}
          var _ktype128 = 0
          var _vtype129 = 0
          rtmp3 = input.readMapBegin()
          _ktype128= rtmp3.ktype
          _vtype129= rtmp3.vtype
          _size127= rtmp3.size
          for (var _i131 = 0; _i131 < _size127; ++_i131)
          {
            key132 = null
            val133 = null
            key132 = input.readString()
            {
              var _size134 = 0
              var rtmp3
              val133 = {}
              var _ktype135 = 0
              var _vtype136 = 0
              rtmp3 = input.readMapBegin()
              _ktype135= rtmp3.ktype
              _vtype136= rtmp3.vtype
              _size134= rtmp3.size
              for (var _i138 = 0; _i138 < _size134; ++_i138)
              {
                key139 = null
                val140 = null
                key139 = input.readString()
                {
                  var _size141 = 0
                  var rtmp3
                  val140 = []
                  var _etype144 = 0
                  rtmp3 = input.readListBegin()
                  _etype144 = rtmp3.etype
                  _size141 = rtmp3.size
                  for (var _i145 = 0; _i145 < _size141; ++_i145)
                  {
                    var elem146 = null
                    elem146 = new ttypes.Mutation()
                    elem146.read(input)
                    val140.push(elem146)
                  }
                  input.readListEnd()
                }
                val133[key139] = val140
              }
              input.readMapEnd()
            }
            this.mutation_map[key132] = val133
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_args')
  if (null != this.mutation_map) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map))
      {
        for(var kiter147 in this.mutation_map)        {
          if (this.mutation_map.hasOwnProperty(kiter147))
          {
            var viter148 = this.mutation_map[kiter147]
            output.writeString(kiter147)
            {
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter148))
              {
                for(var kiter149 in viter148)                {
                  if (viter148.hasOwnProperty(kiter149))
                  {
                    var viter150 = viter148[kiter149]
                    output.writeString(kiter149)
                    {
                      output.writeListBegin(Thrift.Type.STRUCT, viter150.length)
                      {
                        for(var iter151 in viter150)
                        {
                          if (viter150.hasOwnProperty(iter151))
                          {
                            iter151=viter150[iter151]
                            iter151.write(output)
                          }
                        }
                      }
                      output.writeListEnd()
                    }
                  }
                }
              }
              output.writeMapEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_batch_mutate_result.prototype = {}
Cassandra_batch_mutate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_args = function(args){
  this.cfname = null
if( args != null ){  if (null != args.cfname)
  this.cfname = args.cfname
}}
Cassandra_truncate_args.prototype = {}
Cassandra_truncate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_args')
  if (null != this.cfname) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1)
    output.writeString(this.cfname)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_result = function(args){
  this.ire = null
  this.ue = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
}}
Cassandra_truncate_result.prototype = {}
Cassandra_truncate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_args = function(args){
}
Cassandra_describe_schema_versions_args.prototype = {}
Cassandra_describe_schema_versions_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_schema_versions_result.prototype = {}
Cassandra_describe_schema_versions_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size152 = 0
          var rtmp3
          this.success = {}
          var _ktype153 = 0
          var _vtype154 = 0
          rtmp3 = input.readMapBegin()
          _ktype153= rtmp3.ktype
          _vtype154= rtmp3.vtype
          _size152= rtmp3.size
          for (var _i156 = 0; _i156 < _size152; ++_i156)
          {
            key157 = null
            val158 = null
            key157 = input.readString()
            {
              var _size159 = 0
              var rtmp3
              val158 = []
              var _etype162 = 0
              rtmp3 = input.readListBegin()
              _etype162 = rtmp3.etype
              _size159 = rtmp3.size
              for (var _i163 = 0; _i163 < _size159; ++_i163)
              {
                var elem164 = null
                elem164 = input.readString()
                val158.push(elem164)
              }
              input.readListEnd()
            }
            this.success[key157] = val158
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter165 in this.success)        {
          if (this.success.hasOwnProperty(kiter165))
          {
            var viter166 = this.success[kiter165]
            output.writeString(kiter165)
            {
              output.writeListBegin(Thrift.Type.STRING, viter166.length)
              {
                for(var iter167 in viter166)
                {
                  if (viter166.hasOwnProperty(iter167))
                  {
                    iter167=viter166[iter167]
                    output.writeString(iter167)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_args = function(args){
}
Cassandra_describe_keyspaces_args.prototype = {}
Cassandra_describe_keyspaces_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspaces_result.prototype = {}
Cassandra_describe_keyspaces_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size168 = 0
          var rtmp3
          this.success = []
          var _etype171 = 0
          rtmp3 = input.readListBegin()
          _etype171 = rtmp3.etype
          _size168 = rtmp3.size
          for (var _i172 = 0; _i172 < _size168; ++_i172)
          {
            var elem173 = null
            elem173 = new ttypes.KsDef()
            elem173.read(input)
            this.success.push(elem173)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter174 in this.success)
        {
          if (this.success.hasOwnProperty(iter174))
          {
            iter174=this.success[iter174]
            iter174.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_args = function(args){
}
Cassandra_describe_cluster_name_args.prototype = {}
Cassandra_describe_cluster_name_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_cluster_name_result.prototype = {}
Cassandra_describe_cluster_name_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_args = function(args){
}
Cassandra_describe_version_args.prototype = {}
Cassandra_describe_version_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_version_result.prototype = {}
Cassandra_describe_version_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_ring_args.prototype = {}
Cassandra_describe_ring_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_ring_result.prototype = {}
Cassandra_describe_ring_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size175 = 0
          var rtmp3
          this.success = []
          var _etype178 = 0
          rtmp3 = input.readListBegin()
          _etype178 = rtmp3.etype
          _size175 = rtmp3.size
          for (var _i179 = 0; _i179 < _size175; ++_i179)
          {
            var elem180 = null
            elem180 = new ttypes.TokenRange()
            elem180.read(input)
            this.success.push(elem180)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter181 in this.success)
        {
          if (this.success.hasOwnProperty(iter181))
          {
            iter181=this.success[iter181]
            iter181.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_args = function(args){
}
Cassandra_describe_partitioner_args.prototype = {}
Cassandra_describe_partitioner_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_partitioner_result.prototype = {}
Cassandra_describe_partitioner_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_args = function(args){
}
Cassandra_describe_snitch_args.prototype = {}
Cassandra_describe_snitch_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_snitch_result.prototype = {}
Cassandra_describe_snitch_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_keyspace_args.prototype = {}
Cassandra_describe_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_result = function(args){
  this.success = null
  this.nfe = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspace_result.prototype = {}
Cassandra_describe_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_args = function(args){
  this.cfName = null
  this.start_token = null
  this.end_token = null
  this.keys_per_split = null
if( args != null ){  if (null != args.cfName)
  this.cfName = args.cfName
  if (null != args.start_token)
  this.start_token = args.start_token
  if (null != args.end_token)
  this.end_token = args.end_token
  if (null != args.keys_per_split)
  this.keys_per_split = args.keys_per_split
}}
Cassandra_describe_splits_args.prototype = {}
Cassandra_describe_splits_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_args')
  if (null != this.cfName) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1)
    output.writeString(this.cfName)
    output.writeFieldEnd()
  }
  if (null != this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2)
    output.writeString(this.start_token)
    output.writeFieldEnd()
  }
  if (null != this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3)
    output.writeString(this.end_token)
    output.writeFieldEnd()
  }
  if (null != this.keys_per_split) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4)
    output.writeI32(this.keys_per_split)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_splits_result.prototype = {}
Cassandra_describe_splits_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size182 = 0
          var rtmp3
          this.success = []
          var _etype185 = 0
          rtmp3 = input.readListBegin()
          _etype185 = rtmp3.etype
          _size182 = rtmp3.size
          for (var _i186 = 0; _i186 < _size182; ++_i186)
          {
            var elem187 = null
            elem187 = input.readString()
            this.success.push(elem187)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRING, this.success.length)
      {
        for(var iter188 in this.success)
        {
          if (this.success.hasOwnProperty(iter188))
          {
            iter188=this.success[iter188]
            output.writeString(iter188)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_add_column_family_args.prototype = {}
Cassandra_system_add_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_add_column_family_result.prototype = {}
Cassandra_system_add_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_args = function(args){
  this.column_family = null
if( args != null ){  if (null != args.column_family)
  this.column_family = args.column_family
}}
Cassandra_system_drop_column_family_args.prototype = {}
Cassandra_system_drop_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_args')
  if (null != this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1)
    output.writeString(this.column_family)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_drop_column_family_result.prototype = {}
Cassandra_system_drop_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_add_keyspace_args.prototype = {}
Cassandra_system_add_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_add_keyspace_result.prototype = {}
Cassandra_system_add_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_system_drop_keyspace_args.prototype = {}
Cassandra_system_drop_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_drop_keyspace_result.prototype = {}
Cassandra_system_drop_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_update_keyspace_args.prototype = {}
Cassandra_system_update_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_update_keyspace_result.prototype = {}
Cassandra_system_update_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_update_column_family_args.prototype = {}
Cassandra_system_update_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_system_update_column_family_result.prototype = {}
Cassandra_system_update_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {}
}
CassandraClient.prototype = {}
CassandraClient.prototype.login = function(auth_request,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_login(auth_request)
}

CassandraClient.prototype.send_login = function(auth_request){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_login_args()
  args.auth_request = auth_request
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_login = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_login_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.authnx) {
    return callback(result.authnx);
  }
  if (null != result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
}
CassandraClient.prototype.set_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_set_keyspace(keyspace)
}

CassandraClient.prototype.send_set_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_set_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  callback(null)
}
CassandraClient.prototype.get = function(key,column_path,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get(key, column_path, consistency_level)
}

CassandraClient.prototype.send_get = function(key,column_path,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_args()
  args.key = key
  args.column_path = column_path
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get failed: unknown result");
}
CassandraClient.prototype.get_slice = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_slice(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_slice = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_slice_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_slice failed: unknown result");
}
CassandraClient.prototype.get_count = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_count(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_count = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_count_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_count failed: unknown result");
}
CassandraClient.prototype.multiget_slice = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_slice(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_slice = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_slice_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_slice failed: unknown result");
}
CassandraClient.prototype.multiget_count = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_count(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_count = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_count_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_count failed: unknown result");
}
CassandraClient.prototype.get_range_slices = function(column_parent,predicate,range,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_range_slices(column_parent, predicate, range, consistency_level)
}

CassandraClient.prototype.send_get_range_slices = function(column_parent,predicate,range,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_range_slices_args()
  args.column_parent = column_parent
  args.predicate = predicate
  args.range = range
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_range_slices failed: unknown result");
}
CassandraClient.prototype.get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level)
}

CassandraClient.prototype.send_get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_indexed_slices_args()
  args.column_parent = column_parent
  args.index_clause = index_clause
  args.column_predicate = column_predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_indexed_slices failed: unknown result");
}
CassandraClient.prototype.insert = function(key,column_parent,column,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_insert(key, column_parent, column, consistency_level)
}

CassandraClient.prototype.send_insert = function(key,column_parent,column,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_insert_args()
  args.key = key
  args.column_parent = column_parent
  args.column = column
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_insert_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.remove = function(key,column_path,timestamp,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_remove(key, column_path, timestamp, consistency_level)
}

CassandraClient.prototype.send_remove = function(key,column_path,timestamp,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_remove_args()
  args.key = key
  args.column_path = column_path
  args.timestamp = timestamp
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_remove_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.batch_mutate = function(mutation_map,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_batch_mutate(mutation_map, consistency_level)
}

CassandraClient.prototype.send_batch_mutate = function(mutation_map,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_batch_mutate_args()
  args.mutation_map = mutation_map
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.truncate = function(cfname,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_truncate(cfname)
}

CassandraClient.prototype.send_truncate = function(cfname){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_truncate_args()
  args.cfname = cfname
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_truncate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  callback(null)
}
CassandraClient.prototype.describe_schema_versions = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_schema_versions()
}

CassandraClient.prototype.send_describe_schema_versions = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_schema_versions_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_schema_versions failed: unknown result");
}
CassandraClient.prototype.describe_keyspaces = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspaces()
}

CassandraClient.prototype.send_describe_keyspaces = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspaces_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspaces failed: unknown result");
}
CassandraClient.prototype.describe_cluster_name = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_cluster_name()
}

CassandraClient.prototype.send_describe_cluster_name = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_cluster_name_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_cluster_name failed: unknown result");
}
CassandraClient.prototype.describe_version = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_version()
}

CassandraClient.prototype.send_describe_version = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_version_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_version_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_version failed: unknown result");
}
CassandraClient.prototype.describe_ring = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_ring(keyspace)
}

CassandraClient.prototype.send_describe_ring = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_ring_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_ring failed: unknown result");
}
CassandraClient.prototype.describe_partitioner = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_partitioner()
}

CassandraClient.prototype.send_describe_partitioner = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_partitioner_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_partitioner failed: unknown result");
}
CassandraClient.prototype.describe_snitch = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_snitch()
}

CassandraClient.prototype.send_describe_snitch = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_snitch_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_snitch failed: unknown result");
}
CassandraClient.prototype.describe_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspace(keyspace)
}

CassandraClient.prototype.send_describe_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspace failed: unknown result");
}
CassandraClient.prototype.describe_splits = function(cfName,start_token,end_token,keys_per_split,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_splits(cfName, start_token, end_token, keys_per_split)
}

CassandraClient.prototype.send_describe_splits = function(cfName,start_token,end_token,keys_per_split){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_splits_args()
  args.cfName = cfName
  args.start_token = start_token
  args.end_token = end_token
  args.keys_per_split = keys_per_split
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_splits failed: unknown result");
}
CassandraClient.prototype.system_add_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_column_family(cf_def)
}

CassandraClient.prototype.send_system_add_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_column_family failed: unknown result");
}
CassandraClient.prototype.system_drop_column_family = function(column_family,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_column_family(column_family)
}

CassandraClient.prototype.send_system_drop_column_family = function(column_family){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_column_family_args()
  args.column_family = column_family
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_column_family failed: unknown result");
}
CassandraClient.prototype.system_add_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_keyspace(ks_def)
}

CassandraClient.prototype.send_system_add_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_keyspace failed: unknown result");
}
CassandraClient.prototype.system_drop_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_keyspace(keyspace)
}

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_keyspace(ks_def)
}

CassandraClient.prototype.send_system_update_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_column_family(cf_def)
}

CassandraClient.prototype.send_system_update_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_column_family failed: unknown result");
}
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin()
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output)
  } else {
    input.skip(Thrift.Type.STRUCT)
    input.readMessageEnd()
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname)
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid)
    x.write(output)
    output.writeMessageEnd()
    output.flush()
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_login_result()
  this._handler.login(args.auth_request, function(success) {
    result.success = success
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_set_keyspace_result()
  this._handler.set_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_result()
  this._handler.get(args.key, args.column_path, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_slice_result()
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_count_result()
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_slice_result()
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_count_result()
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_range_slices_result()
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_indexed_slices_result()
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_insert_result()
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_remove_result()
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_batch_mutate_result()
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_truncate_result()
  this._handler.truncate(args.cfname, function(success) {
    result.success = success
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_schema_versions_result()
  this._handler.describe_schema_versions(function(success) {
    result.success = success
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspaces_result()
  this._handler.describe_keyspaces(function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_cluster_name_result()
  this._handler.describe_cluster_name(function(success) {
    result.success = success
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_version_result()
  this._handler.describe_version(function(success) {
    result.success = success
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_ring_result()
  this._handler.describe_ring(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_partitioner_result()
  this._handler.describe_partitioner(function(success) {
    result.success = success
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_snitch_result()
  this._handler.describe_snitch(function(success) {
    result.success = success
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspace_result()
  this._handler.describe_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_splits_result()
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function(success) {
    result.success = success
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_column_family_result()
  this._handler.system_add_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_column_family_result()
  this._handler.system_drop_column_family(args.column_family, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_keyspace_result()
  this._handler.system_add_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_keyspace_result()
  this._handler.system_drop_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_keyspace_result()
  this._handler.system_update_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_column_family_result()
  this._handler.system_update_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

