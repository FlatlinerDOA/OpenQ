The Distributed Queue uses a Two-phase commit strategy for writing to the queue.

The first phase Enqueues the value with an expected sequence number that the sender assumes the queue is at. 
This assumes the sender has already read from this or another peer's copy of the queue.



Example:

Initial State:
Client		Peer #1		Peer #2		Peer #3
			1 - Apple	1 - Apple	1 - Apple
2 - Orange 	2 - Orange	2 - Orange	2 - Orange


Client Request: 
// Client has a current cursor position which is a combination of their unique subscriber id, the name of the queue and the latest version the client is aware of.
var currentCursor = new Cursor("urn:myawesomequeue", this.id, 2);

// Client chooses any peer (or it may be chosen for him via a load-balancer)
var peer1Cursor = Peer1.EnqueueAsync([ "Banana", "Pineapple" ], currentCursor);
currentCursor = new Cursor("urn:myawesomequeue", this.id, peer1Cursor.Version);

Peer #1's Accept Process:

EnqueueAsync(values, cursor? = null)
1.1 If cursor is null use Peer #1's current cursor for the queue
   Else check if the cursor is equal to Peer #1's current cursor in the queue
	- If Not Equal - Return Peer #1's current cursor.

1.2 Store the new values at their appropriate indexes (overwriting any uncommitted values in the same positions)
1.3 Iterate through Quorum peers:
    If peer has accepted this cursor already, increment counter
	Else post values to peer with cursor
1.4 If counter is greater than minimum quorum, then atomically update the this peer's current cursor
1.5 Iterate through Quorum peers and update this Peer's cursor on all peers.
1.6 Respond to client with this Peer's updated cursor indicating success.

Peer #2's Accept Process:

UpdateCursor(cursor)
2.1 Store cursor position for corresponding peer
2.2 Iterate through Quorum peers, count how many other peers have accepted this cursor already.
2.3 If count is greater than minimum quorum, then check if new values are stored, if not read values from a random peer in the list of accepted using this peer's current cursor (This will Auto-repair the queue).

New Peer #4 Startup:
3.1 Load current cursor and list of Peers and their Cursors.
3.2 Contact a random Peer x and ReadQueueAsync(currentCursor, 0)
3.3 this.UpdateCursor(Peer x's Cursor).
3.4 Mark self as available